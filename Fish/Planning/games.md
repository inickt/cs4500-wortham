# Memo 10/15

## Game Representation

Our game representation is a tree with two possible values at each branch.
At any point time, there are either possible moves a player could take, or
the game has ended. We use a single Game enumeration to represent these
two cases.

The leaves of our tree are the `End` nodes. Each End node represents a finished
game and the gamestate it ended on. This contains the winning player, along
with all the other information in our game state.

The branches of our tree are the `Turn` values which represent each
possible move that can be taken in the current turn. These nodes contain the current
state of the game as well as a mapping of each possible valid move in this turn
to the Game which will be generated by making that move.

#### Validating and Planning 

Valid move checking amounts to checking if a given move is a key in `Turn`'s
HashMap. Otherwise, if the game is in an `End` state, there are no valid moves.

Planning ahead can be done by viewing each possible `Move` in the current `Turn` and
seeing which `Game` each results in. The HashMap is only accessible if the
game is not yet ended - there is no point in planning ahead in a finished game anyway.

```rs
struct Move {
    penguin_id: PenguinId,
    tile_id: TileId,
}

enum Game {
    Turn { state: GameState, valid_moves: HashMap<Move, Game> },
    End(GameState),
}
```

## External Interface

In the external interface, we provide functions that will allow players
and referees to check valid moves and to plan ahead.

To validate moves, we provide the `valid_moves` function. To plan ahead,
we provide a few functions, namely `get_game_after_move` to "peek" into
the `Game` generated by a given move and `get_state` to view more
detailed information about the game state in a given turn.

These functions are strategy-agnostic - we do not define a "get move that
results in the most End states where a given player wins" for example.
Instead, we provide helpers for traversing a Game that users may wish to
use to implement their own strategies.

```rs
/// Returns the Vec of possible Moves for the current turn.
/// Will return an empty Vec if the Game has ended
fn valid_moves(&self) -> Vec<Move> { ... }

/// Gets the state of the game represented by the current tree node.
fn get_state(&self) -> &GameState { ... }

/// Returns the `Game` that would be produced as a result of taking the given Moves in order.
/// If the move is invalid (not in valid_moves or self is `End`) then the
/// index of the invalid move is returned.
fn get_game_after_move(&self, move: Move) -> Option<&Game> { ... }

/// If the game has ended, return a non-empty Vec of the winning players.a
/// If the game is ongoing, return an empty Vec.
/// 
/// Note that there is no case where a game can end without a winner. Even
/// if all four players were to cheat, the game would end when the third player
/// cheats.
fn get_winning_players(&self) -> Vec<PlayerId> { ... }
```